![IMG_0676](https://github.com/user-attachments/assets/b9ee7756-1bc4-4862-9315-7a04f1535ca6)# Circuit-Simulator
&emsp;This is my attempt at making a basic circuit simulator (This is my inspirations <https://www.falstad.com/circuit/>[link](www.falstad.com/circuit/)). This project is just an RIC circuit simulator. So far the components are just DC voltage sources, wires, resistors, inductors and capacitors. In the future I may add AC voltage sources, diodes, transistors (would require decent change to code), op-amps, voltmeters and ammeters. This would require a fair amount of alterations to UI. This is clearly visible with my chatgpt code that gave me the basic design for the components that only work when they are placed the right way. I do not enjoy graphic design. If I revisit this project I want to work with someone else who can control how it looks or maybe I will just enjoy making UI and visuals more. Next Thing that I would add would be the voltage and current visual aids as seen in the falstad program.
<img width="1308" height="786" alt="Screenshot from 2026-02-15 22-00-02" src="https://github.com/user-attachments/assets/b0c30d7e-d01c-4610-a5df-6633a94e8483" />
&emsp;The first step of the program is creating the basic UI. The code is centered around the basic grid that can be dragged with left click and moved with mouse scroll. Five buttons for placing the different types of components and a button on the top right for live simulation. Black - wire; Green - voltage source; Red - resistor; Yellow - capacitor; Blue - inductor. 
&emsp;When a component is placed, an instance of a class called **component** is created. This allows for each component to be defined as a subclass, and to hold its own set of variables (At this point I have not programmed the ability to customize the voltage, resistance, inductance and capacitance of each component; That would be the next thing to impliment). These instances are then put into an array called **components[]** The coordinates of each of the nodes is added to **storePointConnection**. The nodes that each component is connected to is then stored in **storeConnectionAtPoint**.  
>storePointCoordinates: \[(0, -3), (0, 0), (3, -3), (3, 0), (6, 0)\]  
>storeConnectionsAtPoints: \[\[(0, 0), (2, 0), (3, 0)\], \[(0, 1), (1, 0)\], \[(1, 1), (2, 1), (4, 1), (5, 0)\], \[(3, 1), (4, 0), (6, 0)\], \[(5, 1), (6, 1)\]\]  
>storeConnectionsAtPoints(example): \[\[ (# of element in **components[]**, orientation of component relative to node) ...\], \[The second point that is listed in **storePointCoordinates**\]\]  
<img width="1308" height="786" alt="Screenshot from 2026-02-17 18-46-20" src="https://github.com/user-attachments/assets/20366588-8974-4bae-bdee-7460da0a4eb3" />
&emsp;If you are familiar with Electric Physics, you may have realized that we have already found the first Kirchoff law (dont worry if you missed it, I did as well, and programmed another function to find values I already had). Kirchhoff's Current Law states that the total current entering a junction in an electrical circuit is equal to the total current leaving that junction. Since we have all of the nodes of the circuit, the components theyre connected too, and the orientation of the components (relative to node). 
&emsp;Once we have these variables, we can figure out the current and voltage relationships of these components using kirchoff laws. The first step is simplifying **storeConnectionsAtPoints** This is simplified into:

>storeConnectionReference: \[\[1, 2, 3\], \[0, 2\], \[1, 0, 3, 4\], \[0, 2, 4\], \[2, 3\]\]  
>storeConnectionReference: \[\[the nodes that the first node is connected to\] \[the nodes that the second node is connected too\]\]

&emsp;This is done so that we can simplify the process of pathfinding for the Kirchoff voltage law. To clarify this law states that all closed loops will have a sum of voltages that is equal to 0 (the direction of the voltages must be in reference to the loop, hence some components such as voltage sources will have ""negative"" voltages). First step is choosing a node to begin at. I looked through **storeConnectionReference** to see if there are any nodes with 3 connections, if not it chooses one with 2 connections. This is done to prevent the possibility that the algorithm begins on an offshoot that is not part of the loop (there are still situations where a 2 connection or 3 connection node would not be part of the main structure of the circuit. Also this ignores the possibility of having two loops that are entirely disconected, or connected through one connection, which will not work \[Future addition\]).
![ErrorCaseCS](https://github.com/user-attachments/assets/d4dbe085-754f-4027-868e-d513328de5f5)
&emsp;Once the start node is chosen, a pathfinding algorithm will search through the nodes to find the voltage loops within the circuit. To begin a list called **Nodes Explored**, with the first point being the start node. This list will be kept through the program to record the nodes that the algorithm explored (not all of the nodes explored, but the ones that were explored in higher points of the recuring function, aka the ones that are in the direct path of this search). This process begins by looking at all of the nodes connected to the current node **(storeConnectionReference\[currentNode\])**. The algorithm will (eventually) explore all of these connected nodes. The first node is chosen. It is checked to see if it is the previous node (mainly to make sure that the loop doesn't go *startnode-node1-startnode* and create a loop), which if true will mean nothing happens (explore other connected nodes). Then it will check if it is an unexplored node. If this is true, the current node will be added to **NodesExplored**, and the algorithm will restart from the next node. If not it will then check if it was **nodesExplored\[0\]**. If it was it will then it means that a loop was found. The loop is first checked to make sure that it is not a duplicate of another loop but in the opposite direction, which if not this path will then be added to an array called **currentLoops** (It is called this because of the law of superposition). The exact data that is appended to **currentLoops** is called **componentConnections**, which is basically the list of the components that create the path that we have found (and also their orientation). If the it is not **nodesExplored\[0\]**, then it is an already explored node, which means it can be ignored. Once all of the adjacent nodes have been explored, the algorithm returns to the previous node and explores any untouched nodes there.  
![IMG_0676](https://github.com/user-attachments/assets/91ba846c-e258-4559-a970-62b5c98f8e77)

&emsp;As I write this text I realized that there was an error in my code, which anyone who knows kirchoff laws well will notice. This being the possibility of redundant loops. Given the diagram above, only 3 equations are necessary to describe the Kirchoff Voltage law. 10 were found with 5 being repeats. This means that two of the **currentLoops** found are redundant. Worse than that, these extra equations will prevent the linear algebra equation from working. This explains some errors i was having earlier. Later on in the code I will be using some function to figure out which ones are useless so that I don't have that problem anymore. I will describe how that works when I make that later.  
&emsp;Now that we have found the Kirchoff equations, we can move on to the linear algebra equations. What we are trying to solve for is the current and voltage of the circuit. Given the circuit above, we have 7 components, so we will have 14 variables to solve for(V1, I1, V2, I2...). We will then have to create 14 different equations in order to solve this problem. The first 7 of these will be pretty basic. Each Component will have an equation that will be used to determine the voltage, current or relationship between those two variables of each component.  
| Component | Physics equation | Program Equation |
| :---: | :---: | :---: |
| Wire | V = 0 | V = 0 |
| Voltage Source | V = a | V = a |
| Resistor | V = IR | V - IR = 0 |
| Capacitor | $i(t)=C\frac{v(t)}{d}$ | V - CI = Vp |
| Inductor | $v(t)=L\frac{i(t)}{d}$ | I - LI = Ip |

&emsp; Vp and Ip represent the previous voltage and inductance. These values will be held within the instances of each individual component. They will be changed every time that a new solution is made.  
&emsp; This process would then generate 7 different equations. For the last 7 we need to use the Kirchoff laws. As you may remember we have 5 current law equations. That being said, one of them is redundant. If you have all of the current laws except for one, you will be able to calculate the last equation. You can imagine that if you add all of the other node equations together, all but the connections to the last node will cancel out giving you the final equation.
>storeConnectionsAtPoints: \[\[(0, 0), (2, 0), (3, 0)\], \[(0, 1), (1, 0)\], \[(1, 1), (2, 1), (4, 1), (5, 0)\], \[(3, 1), (4, 0), (6, 0)\], \[(5, 1), (6, 1)\]\]  
>I0 + I2 + I3 = 0  
>\-I0 + I1 = 0  
>\-I1 \- I2 \- I4 + I5 = 0  
>\-I3 + I4 + I6 = 0  
>\[\-I5 \- I6 = 0\]

![IMG_0677](https://github.com/user-attachments/assets/54b53876-7e34-4a6f-ab60-4e3b20b2b0c7)
&emsp;Then we have to sort through the **currentLoops**. The purpose of this algorith is to determine if one of the circuits is the same as two other circuits combined. My algorithm will be based on checking each **currentLoop** to see if its subcomponents have been acounted for before. Well start off with **currentLoops[0 & 1]** These two are not made of other circuit loops, because there are only 2 of them. All of the components that are in these arrays will then be added to a list 
